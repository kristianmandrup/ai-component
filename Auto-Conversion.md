# Auto Conversion

Ideally we want to support auto-conversion between most popular frameworks to the extend possible/feasible.

- [Aurelia vs Angular](http://blog.durandal.io/2015/03/16/aurelia-and-angular-2-code-side-by-side/)
- [Aurelia vs Angular part 2](http://blog.durandal.io/2015/03/17/aurelia-angular-2-0-code-side-by-side-part-2/)

We estimate we can automate a *rough* conversion between Aurelia and Angular2 that gets us 50-80% of the way.
This still makes it way easier to port components between Aurelia and Angular2 as it cuts down the grunt work 
and leaves the finer details to the developer. 

## VMs

### Aurelia VM

```js
import { computed } from 'aurelia-framework'; 

@computed('fullName', ['firstName', 'lastName']);
export class MyApp {  
  constructor(){
    this.firstName = 'John';
    this.lastName = 'Doe';
  }
  
  get fullName(){
    return `${this.firstName} ${this.lastName}`;
  }
}
```

To convert to Angular, we need to somehow tell the converter which properties are computed.
We could do this with a faux `@computed` decorator as shown here.
This decorator will then also be included on the Angular class (see below).

### Angular 2 VM

This is really tricky! Perhaps the best way is to insert a decorator on the class for each computed property.

```js
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
class MyApp {  
  constructor() {
    this.firstName = 'John';
    this.lastName = 'Doe';
    this.updateFullname();
  }

  updateFullname(){
    this.fullName = this.firstName + " " + this.lastName;
  }

  firstNameChanged($event, first){
    this.firstName = first.value;
    this.updateFullname();
  }

  lastNameChanged($event, last){
    this.lastName = last.value;
    this.updateFullname();
  }
}
```

With decorator, becomes:

```js
import { computed } from 'ai-converter/angular2/decorators';
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
@computed('fullName', ['firstName', 'lastName']);
class MyApp {  
  constructor() {
    this.firstName = 'John';
    this.lastName = 'Doe';
    this.updateFullname();
  }
}
```

Then we assume the following methods are generated by decorator!

```
  // generated
  updateFullname(){
    this.fullName = this.firstName + " " + this.lastName;
  }

  firstNameChanged($event, first){
    this.firstName = first.value;
    this.updateFullname();
  }

  lastNameChanged($event, last){
    this.lastName = last.value;
    this.updateFullname();
  }
```

## String interpolation

Angular `{{hero.id}}` vs. Aurelia: `${hero.id}`

## Loops

### Angular2 loops

```html
<div *ngFor="let hero of heroes">
  {{hero.id}} - {{hero.name}}
</div>
```

### Aurelia loops

```html
<div repeat.for="hero of heroes">
  ${hero.id} - ${hero.name}
</div>
```

## Dependency Injection (DI)

### Angular 2 DI

```js
import { Logger }     from '../logger.service';
@Injectable()
export class HeroService {
  constructor(private logger: Logger) {  }
}
```

### Aurelia DI

```js
import { Logger }     from '../logger.service';
@inject(Logger)
export class HeroService {
  constructor(logger) {  }
}
```

Or using TypeScript

```js
import { autoinject }     from 'aurelia-framework';
import { Logger }     from '../logger.service';
@autoinject
export class HeroService {
  constructor(private logger : Logger) {  }
}
```


## Forms

### Aurelia 2 form

View model

```js
export class ContactForm {  
  constructor(){
    this.contact = new Contact('John', 'Doe');
  }

  onSubmit() {

  }  
}
```

View form

```html
<form submit.delegate="onSubmit()" with.bind="contact">  
  First Name:
  <input type="text" value.bind="firstName">
  Last Name:
  <input type="text" value.bind="lastName">
  Full Name: ${fullName}
</form>  
```

### Angular 2 FormControl

If the view has a form with fields, the VM must construct special binding constructs:
- `FormControlGroup`
- `FormControl`

View model

```js
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
class ContactForm {  
  constructor() {
    this.contact = new Contact('John', 'Doe');  
    this.contactForm = new FormControlGroup("form", [
      new FormControl("firstName"),
      new FormControl("lastName")
    ]);
    this.contactForm.readFrom(this.contact);
  }

  onSubmit() {

  }
}
```

View form

```html
<form (ngSubmit)="onSubmit()" [control-group]='contactForm'>  
  <label [attr.for]="question.key">{{question.label}}</label>
  <input type="text" control="firstName">
  <br/>
  Last Name:
  <input type="text" control="lastName">
  Full Name: {{contact.fullName}}
</form> 
```

## Templates

Should be pretty straight forward to convert the templates and binding syntax are also more or less 1-1.

### Aurelia templates 

`app.html`

```
<template>  
  First Name:
  <input type="text" value.bind="firstName">
  Last Name:
  <input type="text" value.bind="lastName">
  Full Name: ${fullName}
</template>
```

### Angular 2 templates

`app.html`

```
First Name:  
<input type="text" [value]="firstName" #first (change)="firstNameChanged($event, first)" (input)="firstNameChanged($event, first)">  
Last Name:  
<input type="text" [value]="lastName" #last (change)="lastNameChanged($event, last)" (input)="lastNameChanged($event, last)">  
Full Name: {{fullName}}  
```