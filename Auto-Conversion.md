# Auto Conversion

Ideally we want to support auto-conversion between most popular frameworks to the extend possible/feasible.

- [Aurelia vs Angular](http://blog.durandal.io/2015/03/16/aurelia-and-angular-2-code-side-by-side/)
- [Aurelia vs Angular part 2](http://blog.durandal.io/2015/03/17/aurelia-angular-2-0-code-side-by-side-part-2/)

## VMs

### Aurelia VM

```js
export class MyApp {  
  constructor(){
    this.firstName = 'John';
    this.lastName = 'Doe';
  }
  get fullName(){
    return `${this.firstName} ${this.lastName}`;
  }
}
```

### Angular 2 VM

This is really tricky! Perhaps the best way is to insert a decorator on the class for each computed property.

```js
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
class MyApp {  
  constructor() {
    this.firstName = 'John';
    this.lastName = 'Doe';
    this.updateFullname();
  }

  updateFullname(){
    this.fullName = this.firstName + " " + this.lastName;
  }

  firstNameChanged($event, first){
    this.firstName = first.value;
    this.updateFullname();
  }

  lastNameChanged($event, last){
    this.lastName = last.value;
    this.updateFullname();
  }
}
```

With decorator, becomes:

```js
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
@computed('fullName', ['firstName', 'lastName']);
class MyApp {  
  constructor() {
    this.firstName = 'John';
    this.lastName = 'Doe';
    this.updateFullname();
  }
}
```

Where we assume the following methods are generated by decorator!

```
  // generated
  updateFullname(){
    this.fullName = this.firstName + " " + this.lastName;
  }

  firstNameChanged($event, first){
    this.firstName = first.value;
    this.updateFullname();
  }

  lastNameChanged($event, last){
    this.lastName = last.value;
    this.updateFullname();
  }
```


## Forms

### Angular 2 form VM

```js
export class ContactForm {  
  constructor(){
    this.contact = new Contact('John', 'Doe');
  }
}
```

### Angular 2 form VM

If the view has a form with fields, the VM must construct special binding constructs:
- `FormControlGroup`
- `FormControl`

```js
import {Component, Template} from 'angular2/angular2';

@Component({selector: 'my-app'})
@Template({url: 'app.html'})
class ContactForm {  
  constructor() {
    this.contact = new Contact('John', 'Doe');  
    this.contactForm = new FormControlGroup("form", [
      new FormControl("firstName"),
      new FormControl("lastName")
    ]);
    this.contactForm.readFrom(this.contact);
  }
}
```

## Templates

Should be pretty straight forward to convert the templates and binding syntax are also more or less 1-1.

### Aurelia templates 

`app.html`

```
<template>  
  First Name:
  <input type="text" value.bind="firstName">
  Last Name:
  <input type="text" value.bind="lastName">
  Full Name: ${fullName}
</template>
```

### Angular 2 templates

`app.html`

```
First Name:  
<input type="text" [value]="firstName" #first (change)="firstNameChanged($event, first)" (input)="firstNameChanged($event, first)">  
Last Name:  
<input type="text" [value]="lastName" #last (change)="lastNameChanged($event, last)" (input)="lastNameChanged($event, last)">  
Full Name: {{fullName}}  
```